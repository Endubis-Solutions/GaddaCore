generator client {
  provider = "prisma-client"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  role          UserRole @default(USER)
  network       String   @default("preprod")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  arbitrator   Arbitrator?
  escrows      Escrow[]
  disputes     Dispute[]
  resolutions  Resolution[]
  activityLogs ActivityLog[]
  transactions Transaction[]

  @@index([walletAddress])
  @@index([role])
  @@index([network])
}

model Arbitrator {
  id                 String   @id @default(cuid())
  walletAddress      String   @unique
  name               String?
  bio                String?
  expertise          String[]
  isQualified        Boolean  @default(false)
  qualificationScore Int      @default(0)
  reputationScore    Float    @default(0.5)

  isActive Boolean @default(true)

  lockedAmount BigInt @default(0)
  lockedTxHash String

  totalEarned BigInt @default(0)
  totalLost   BigInt @default(0)

  totalCases   Int @default(0)
  correctVotes Int @default(0)
  wrongVotes   Int @default(0)

  lastActiveAt DateTime?
  updatedAt    DateTime  @updatedAt

  // Relations
  user        User         @relation(fields: [walletAddress], references: [walletAddress])
  resolutions Resolution[]
  disputes    Dispute[]    @relation("ArbitratorDisputes")
  votes       Vote[]

  @@index([reputationScore])
  @@index([isQualified])
  @@index([isActive])
  @@index([lockedAmount])
}

model Escrow {
  id            String       @id @default(cuid())
  scriptAddress String
  status        EscrowStatus @default(AWAITING_RECIPIENT)

  funderAddress    String
  funderStakeInAda Float

  recipientAddress    String
  recipientStakeInAda Float?

  contractIpfsHash      String
  recipientLockDeadline DateTime
  submissionDeadline    DateTime
  resolutionDeadline    DateTime?

  scriptCbor String?

  approvedAt DateTime?
  disputedAt DateTime?
  resolvedAt DateTime?

  // Relations
  users        User[]
  dispute      Dispute?
  resolution   Resolution?
  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([funderAddress])
  @@index([recipientAddress])
  @@index([status])
  @@index([createdAt])
}

enum TransactionCurrency {
  ADA
}

enum TransactionType {
  CREATE_ESCROW
  DEPOSIT_COLLATERAL
  CANCEL
  RELEASE_FUNDS
  DISPUTE_INITIATOR
  DISPUTE_RECIPIENT
  VOTE
}

model Transaction {
  id       String              @id @default(cuid())
  txHash   String              @unique
  datum    Json
  amount   Float               @default(0)
  currency TransactionCurrency @default(ADA)
  reason   String?
  type     TransactionType     @default(CREATE_ESCROW)

  // Relations
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  escrow    Escrow   @relation(fields: [escrowId], references: [id])
  escrowId  String
  dispute   Dispute? @relation(fields: [disputeId], references: [id])
  disputeId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Dispute {
  id                        String  @id @default(cuid())
  funderEvidenceIpfsHash    String?
  recipientEvidenceIpfsHash String?

  status                  DisputeStatus @default(PENDING)
  requiredArbitratorCount Int           @default(3)
  resolvedAt              DateTime?
  resolutionDeadline      DateTime?

  // Relations
  users        User[]
  escrow       Escrow        @relation(fields: [escrowId], references: [id], onDelete: Cascade)
  escrowId     String        @unique
  votes        Vote[]
  resolution   Resolution?
  arbitrators  Arbitrator[]  @relation("ArbitratorDisputes")
  transactions Transaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([escrowId])
  @@index([status])
  @@index([createdAt])
}

model Vote {
  id           String           @id @default(cuid())
  disputeId    String
  dispute      Dispute          @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  arbitratorId String
  arbitrator   Arbitrator       @relation(fields: [arbitratorId], references: [id], onDelete: Cascade)
  decision     ResolutionResult
  reason       String?
  txHash       String?
  createdAt    DateTime         @default(now())

  @@unique([disputeId, arbitratorId])
  @@index([disputeId])
  @@index([arbitratorId])
  @@index([decision])
}

model Resolution {
  id       String           @id @default(cuid())
  escrowId String           @unique
  escrow   Escrow           @relation(fields: [escrowId], references: [id], onDelete: Cascade)
  result   ResolutionResult

  arbitrators Arbitrator[]

  txHash     String
  resolvedAt DateTime @default(now())
  createdAt  DateTime @default(now())

  // Relations
  disputeId String?  @unique
  dispute   Dispute? @relation(fields: [disputeId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([escrowId])
  @@index([txHash])
  @@index([createdAt])
}

model ActivityLog {
  id                 String     @id @default(cuid())
  entityType         EntityType
  entityId           String
  action             String
  performedBy        String
  performedByAddress String?
  metadata           Json?
  txHash             String?
  createdAt          DateTime   @default(now())

  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([performedBy])
  @@index([createdAt])
}

enum UserRole {
  USER
  ARBITRATOR
  ADMIN
}

enum EscrowStatus {
  AWAITING_RECIPIENT
  ACTIVE
  APPROVED
  DISPUTED

  RESOLVED
  CANCELLED
}

enum DisputeStatus {
  PENDING
  ASSIGNED
  IN_REVIEW
  RESOLVED
  EXPIRED
}

enum DisputeRaisedBy {
  FUNDER
  RECIPIENT
}

enum ResolutionResult {
  RELEASE
  REFUND
}

enum EntityType {
  USER
  ARBITRATOR
  ESCROW
  DISPUTE
  RESOLUTION
}
