generator client {
  provider = "prisma-client"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// User model for wallet authentication
model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  role          UserRole @default(USER)
  network       String   @default("preprod")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relationships
  arbitrator         Arbitrator?
  escrows            Escrow[] // As funder
  disputes           Dispute[] // Disputes they've raised
  resolutions        Resolution[] // Resolutions they've made
  activityLogs       ActivityLog[]
  escrowTransactions EscrowTransaction[]

  // Indexes
  @@index([walletAddress])
  @@index([role])
  @@index([network])
}

// Arbitrator with locked funds (from your existing)
model Arbitrator {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  name          String?
  description   String?
  expertise     String[] // e.g., ["DeFi", "NFTs", "Gaming"]

  // Verification flags
  isQualified        Boolean @default(false)
  qualificationScore Int     @default(0)
  isActive           Boolean @default(true)

  // Locked funds (stake)
  lockedAmount BigInt  @default(0)
  lockedTxHash String?

  // Token incentives
  totalEarned BigInt @default(0)
  totalLost   BigInt @default(0)

  // Performance stats
  totalCases      Int   @default(0)
  correctVotes    Int   @default(0)
  wrongVotes      Int   @default(0)
  reputationScore Float @default(0.5)

  // Timestamps
  registeredAt DateTime  @default(now())
  lastActiveAt DateTime?
  updatedAt    DateTime  @updatedAt

  // Relationships
  user        User         @relation(fields: [walletAddress], references: [walletAddress])
  resolutions Resolution[] // Arbitrator's resolutions
  disputes    Dispute[] // Disputes they've been assigned

  // Indexes
  @@index([reputationScore])
  @@index([isQualified])
  @@index([isActive])
  @@index([lockedAmount])
}

// Main escrow transaction model
model Escrow {
  id            String @id @default(cuid())
  txHash        String @unique
  scriptAddress String

  amount    BigInt
  amountAda Float

  funderAddress       String
  funderPubKeyHash    String? // optional â€” not sent from frontend
  recipientAddress    String
  recipientPubKeyHash String? // optional

  status EscrowStatus @default(AWAITING_RECIPIENT)

  disputeDeadline       DateTime?
  recipientLockDeadline DateTime?

  // Important: datum must be Json (object), not string
  datum            Json
  contractIpfsHash String?

  // Auto-managed timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lockedAt  DateTime @default(now())

  // Optional / future-use fields (keep optional)
  resolutionDeadline DateTime?
  datumHash          String?
  scriptCbor         String?
  confirmations      Int       @default(0)
  blockHeight        Int?
  blockHash          String?
  approvedAt         DateTime?
  disputedAt         DateTime?
  resolvedAt         DateTime?

  // Relationships
  userId             String?
  user               User?               @relation(fields: [userId], references: [id], onDelete: SetNull)
  dispute            Dispute?
  resolution         Resolution?
  escrowTransactions EscrowTransaction[]

  // Indexes
  @@index([txHash])
  @@index([funderAddress])
  @@index([recipientAddress])
  @@index([status])
  @@index([createdAt])
}

model EscrowTransaction {
  id     String @id @default(cuid())
  txHash String @unique

  user   User   @relation(fields: [userId], references: [id])
  userId String

  reason String

  escrow   Escrow @relation(fields: [escrowId], references: [id])
  escrowId String
}

enum EscrowStatus {
  AWAITING_RECIPIENT
  ACTIVE
  APPROVED
  DISPUTED
  RESOLVED
  EXPIRED
  CANCELLED
}

// Dispute model
model Dispute {
  id       String @id @default(cuid())
  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id], onDelete: Cascade)

  // Who raised the dispute
  raisedBy        DisputeRaisedBy // FUNDER|RECIPIENT
  raisedById      String?
  raisedByAddress String

  // Dispute details
  reason   String?
  evidence String? // IPFS hash or URL
  txHash   String? // Transaction that raised dispute

  // Status
  status DisputeStatus @default(PENDING)

  // Assignment for arbitration
  assignedArbitratorId String?
  assignedArbitrator   Arbitrator? @relation(fields: [assignedArbitratorId], references: [id])

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  resolvedAt DateTime?

  // Relationships
  resolution Resolution?
  user       User?       @relation(fields: [userId], references: [id])
  userId     String?

  @@index([escrowId])
  @@index([raisedByAddress])
  @@index([status])
  @@index([assignedArbitratorId])
  @@index([createdAt])
}

// Resolution model (for both direct and arbitrated resolutions)
model Resolution {
  id       String @id @default(cuid())
  escrowId String @unique
  escrow   Escrow @relation(fields: [escrowId], references: [id], onDelete: Cascade)

  // Resolution type
  type   ResolutionType // DIRECT_RELEASE|DIRECT_REFUND|ARBITRATED_RELEASE|ARBITRATED_REFUND
  result ResolutionResult // RELEASE|REFUND

  // Who resolved it
  resolvedBy        ResolutionBy // FUNDER|RECIPIENT|ARBITRATOR
  resolvedById      String?
  resolvedByAddress String

  // Arbitrator info if applicable
  arbitratorId String?
  arbitrator   Arbitrator? @relation(fields: [arbitratorId], references: [id])

  // Payout details
  payoutAddress   String
  payoutAmount    BigInt
  payoutAmountAda Float

  // Transaction
  txHash String

  // Timestamps
  createdAt  DateTime @default(now())
  resolvedAt DateTime @default(now())

  // Relationships
  disputeId String?  @unique
  dispute   Dispute? @relation(fields: [disputeId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([escrowId])
  @@index([txHash])
  @@index([resolvedByAddress])
  @@index([createdAt])
}

// Activity log for audit trail
model ActivityLog {
  id String @id @default(cuid())

  // What entity this log is for
  entityType EntityType // ESCROW|DISPUTE|RESOLUTION|USER|ARBITRATOR
  entityId   String

  // Action details
  action             String // CREATED|LOCKED|APPROVED|DISPUTED|ASSIGNED|RESOLVED|UPDATED
  performedBy        String // wallet address or user ID
  performedByAddress String?

  // Metadata
  metadata Json?
  txHash   String?

  // Timestamps
  createdAt DateTime @default(now())

  // Relationships
  userId String?
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([performedBy])
  @@index([createdAt])
}

// Enums (updated with your existing + new ones)
enum UserRole {
  USER
  ARBITRATOR
  ADMIN
}

enum DisputeStatus {
  PENDING
  ASSIGNED
  IN_REVIEW
  RESOLVED
  EXPIRED
}

enum DisputeRaisedBy {
  FUNDER
  RECIPIENT
}

enum ResolutionType {
  DIRECT_RELEASE // Funder directly releases
  DIRECT_REFUND // Funder directly refunds
  ARBITRATED_RELEASE // Arbitrator decides to release
  ARBITRATED_REFUND // Arbitrator decides to refund
}

enum ResolutionResult {
  RELEASE
  REFUND
}

enum ResolutionBy {
  FUNDER
  RECIPIENT
  ARBITRATOR
}

enum EntityType {
  USER
  ARBITRATOR
  ESCROW
  DISPUTE
  RESOLUTION
}
